{"ast":null,"code":"import * as React from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs';\nfunction useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(_ref => {\n      let {\n        data\n      } = _ref;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(error => {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    useErrorBoundary: defaultedOptions.useErrorBoundary,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport { useBaseQuery };","map":{"version":3,"mappings":"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","names":["useBaseQuery","options","Observer","queryClient","useQueryClient","context","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedOptions","defaultQueryOptions","_optimisticResults","onError","notifyManager","batchCalls","onSuccess","onSettled","suspense","staleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","observer","React","useState","result","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","undefined","subscribe","getCurrentResult","useEffect","setOptions","listeners","isLoading","isFetching","fetchOptimistic","then","data","catch","error","clearReset","getHasError","useErrorBoundary","query","getCurrentQuery","notifyOnChangeProps","trackResult"],"sources":["/Users/jiali/project/reactPractice2/customhook/node_modules/@tanstack/react-query/src/useBaseQuery.ts"],"sourcesContent":["import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"]},"metadata":{},"sourceType":"module"}